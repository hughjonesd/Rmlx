% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compile.R
\name{mlx_compile}
\alias{mlx_compile}
\title{Compile an MLX Function for Optimized Execution}
\usage{
mlx_compile(f, shapeless = FALSE)
}
\arguments{
\item{f}{An R function that takes MLX arrays as arguments and returns
MLX array(s). The function must be pure (no side effects) and use only
MLX operations.}

\item{shapeless}{Logical. If \code{TRUE}, the compiled function won't recompile
when input shapes change. However, changing input dtypes or number of
dimensions still triggers recompilation. Default: \code{FALSE}}
}
\value{
A compiled function with the same signature as \code{f}. The first call
will be slow (tracing and compilation), but subsequent calls will be
much faster.
}
\description{
Returns a compiled version of a function that traces and optimizes the
computation graph on first call, then reuses the compiled graph for
subsequent calls with matching input shapes and types.
}
\details{
\subsection{How Compilation Works}{

When you call \code{mlx_compile(f)}, it returns a new function immediately without
any tracing. The actual compilation happens on the \strong{first call} to the
compiled function:
\enumerate{
\item \strong{First call}: MLX traces the function with placeholder inputs, builds
the computation graph, optimizes it (fusing operations, eliminating
redundancy), and caches the result. This is slow.
\item \strong{Subsequent calls}: If inputs have the same shapes and dtypes, MLX
reuses the cached compiled graph. This is fast.
\item \strong{Recompilation}: Occurs when input shapes change (unless \code{shapeless = TRUE}),
input dtypes change, or the number of arguments changes.
}
}

\subsection{Requirements for Compiled Functions}{

Your function must:
\itemize{
\item Accept only MLX arrays as arguments
\item Return MLX array(s) - either a single mlx object or a list of mlx objects
\item Use only MLX operations (no conversion to R)
\item Be pure (no side effects, no external state modification)
}

Your function \strong{cannot}:
\itemize{
\item Print or evaluate arrays during execution (\code{print()}, \code{as.matrix()},
\code{as.numeric()}, \code{[[} extraction, etc.)
\item Use control flow based on array values (\verb{if (x > 0)} where \code{x} is an array)
\item Modify external variables or have other side effects
\item Return non-MLX values
}
}

\subsection{Performance Benefits}{
\itemize{
\item \strong{Operation fusion}: Combines multiple operations into optimized kernels
\item \strong{Memory reduction}: Eliminates intermediate allocations
\item \strong{Overhead reduction}: Bypasses R/C++ call overhead for fused operations
}

Typical speedups range from 2-10x for operation-heavy functions.
}

\subsection{Shapeless Compilation}{

Setting \code{shapeless = TRUE} allows the compiled function to handle varying
input shapes without recompilation:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Regular compilation - recompiles for each new shape
fast_fn <- mlx_compile(matmul_fn)
fast_fn(mlx_zeros(c(10, 64)), weights)  # Compiles for shape (10, 64)
fast_fn(mlx_zeros(c(20, 64)), weights)  # Recompiles for shape (20, 64)

# Shapeless compilation - compiles once
fast_fn <- mlx_compile(matmul_fn, shapeless = TRUE)
fast_fn(mlx_zeros(c(10, 64)), weights)  # Compiles once
fast_fn(mlx_zeros(c(20, 64)), weights)  # No recompilation!
}\if{html}{\out{</div>}}

Shapeless mode sacrifices some optimization opportunities
but avoids recompilation costs. Use it when processing variable-sized batches.
}
}
\examples{
# Simple example
matmul_add <- function(x, w, b) {
  (x \%*\% w) + b
}

# Compile it (returns immediately, no tracing yet)
fast_fn <- mlx_compile(matmul_add)

# First call: slow (traces and compiles)
x <- mlx_rand_normal(c(32, 128))
w <- mlx_rand_normal(c(128, 256))
b <- mlx_rand_normal(c(256))
result <- fast_fn(x, w, b)  # Compiles during this call

# Subsequent calls: fast (uses cached graph)
for (i in 1:1000) {
  result <- fast_fn(batch_data[[i]], w, b)  # Very fast!
}

# Multiple returns
forward_and_norm <- function(x, w) {
  y <- x \%*\% w
  norm <- sqrt(sum(y * y))
  list(y, norm)  # Return list of mlx objects
}

compiled_fn <- mlx_compile(forward_and_norm)
results <- compiled_fn(x, w)  # Returns list(y, norm)

}
\seealso{
\code{\link[=mlx_disable_compile]{mlx_disable_compile()}}, \code{\link[=mlx_enable_compile]{mlx_enable_compile()}}

\href{https://ml-explore.github.io/mlx/build/html/usage/compile.html}{mlx.core.compile}
}
