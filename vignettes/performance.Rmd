---
title: "Performance Benchmarks"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Performance Benchmarks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
run_bench <- TRUE
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = run_bench
)
```

## Overview

This vignette compares the runtime of a few core operations in base R and
`Rmlx`. 

```{r libraries}
library(Rmlx)
library(bench)
library(dplyr)
library(ggplot2)
```

## Matrix addition

```{r bench-add}
mat_sizes <- c(256, 512, 1024)
add_results <- bind_rows(lapply(mat_sizes, function(n) {
  A_r <- matrix(runif(n * n), n, n)
  B_r <- matrix(runif(n * n), n, n)
  A_mlx <- as_mlx(A_r)
  B_mlx <- as_mlx(B_r)

  mb <- bench::mark(
    base = { A_r + B_r },
    rmlx = { as.matrix(A_mlx + B_mlx) },
    iterations = 5,
    check = FALSE
  )
  mb$size <- n
  mb
}))

ggplot(add_results, aes(x = factor(size), y = as.numeric(median), 
                        fill = as.character(expression))) +
  geom_col(position = "dodge") +
  labs(
    title = "Matrix addition timing (median)",
    x = "Matrix dimension",
    y = "Median time",
    fill = "Implementation"
  )
```

## Matrix multiplication

```{r bench-matmul}
matmul_results <- bind_rows(lapply(mat_sizes, function(n) {
  A_r <- matrix(runif(n * n), n, n)
  B_r <- matrix(runif(n * n), n, n)
  A_mlx <- as_mlx(A_r)
  B_mlx <- as_mlx(B_r)

  mb <- bench::mark(
    base = { A_r %*% B_r },
    rmlx = { as.matrix(A_mlx %*% B_mlx) },
    iterations = 3,
    check = FALSE
  )
  mb$size <- n
  mb
}))

ggplot(matmul_results, aes(x = factor(size), y = as.numeric(median), 
                        fill = as.character(expression))) +
  geom_col(position = "dodge") +
  labs(
    title = "Matrix multiplication timing (median)",
    x = "Matrix dimension",
    y = "Median time",
    fill = "Implementation"
  )
```

## Linear system solves

```{r bench-solve}
solve_results <- bind_rows(lapply(mat_sizes, function(n) {
  A_r <- matrix(rnorm(n * n), n, n)
  A_r <- crossprod(A_r) + diag(n) * 1e-3
  b_r <- matrix(rnorm(n), n, 1)
  A_mlx <- as_mlx(A_r)
  b_mlx <- as_mlx(b_r)

  mb <- bench::mark(
    base = { solve(A_r, b_r) },
    rmlx = { as.matrix(solve(A_mlx, b_mlx)) },
    iterations = 3,
    check = FALSE
  )
  mb$size <- n
  mb
}))

ggplot(solve_results, aes(x = factor(size), y = as.numeric(median), 
                        fill = as.character(expression))) +
  geom_col(position = "dodge") +
  labs(
    title = "Linear solve timing (median)",
    x = "Matrix dimension",
    y = "Median time",
    fill = "Implementation"
  )
```



## Notes

- Numeric data resides in single-precision (`float32`) when stored as `mlx` arrays; logical data uses MLX `bool`.
- When comparing timings, make sure MLX is configured for GPU execution and
  consider calling `mlx_synchronize("gpu")` before reading the results to avoid
  asynchronous delays.
- The exact speedups will vary depending on the problem size, the GPU available,
  and whether the GPU is already warm.
